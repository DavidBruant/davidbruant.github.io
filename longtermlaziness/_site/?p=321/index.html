<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>The web performance story</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/css/main.css">

    </head>
    <body>

        <div class="site">
          <div class="header">
            <h1 class="title"><a href="/">Long-term laziness</a></h1>
            <a class="extra" href="/">home</a>
          </div>

          <h2>The web performance story</h2>
<p class="meta">22 Jul 2012</p>

<div class="post">
<p>This blogpost is mostly a reaction to <a href="http://www.youtube.com/watch?v=UJPdhx5zTaw">Daniel Clifford&#8217;s Google I/O 2012 talk: &#8220;Breaking the JavaScript Speed Limit with V8&#8243;</a>. I&#8217;m reacting only to this talk. I don&#8217;t know Daniel Clifford and I have nothing against him personally whatsoever. I think V8 is an excellent product, that&#8217;s not what I&#8217;m talking about. I would have things to say about the &#8220;optimize your code for engine X&#8221; trend, but I won&#8217;t even talk about that.</p>

<p>I&#8217;d like to take a step back to talk about performance in general and focus on as well as criticizing a bit how things are presented in the talk. Once again, although I&#8217;ll be mentioning Daniel Clifford in my post but I&#8217;m criticizing the talk and not the person.</p>

<h2>Why performance matters?</h2>

<p>Daniel Clifford&#8217;s answer is that better performance allow to do things that weren&#8217;t possible, because bad performance was getting in the way of a good experience. I agree with this analysis.</p>

<p>One consequence is that you should care about performance only if either it currently degrades the experience of the product you&#8217;re doing or gets in the way of an improvement. If that&#8217;s not the case, move on. I&#8217;m serious on that point. Too often in technical arguments, people will talk about performance when it actually doesn&#8217;t matter since it wouldn&#8217;t noticeably improve the user experience.</p>

<h2>Performance in software</h2>

<p>If we want to talk about web performance, let&#8217;s start from the beginning, because improving your JavaScript code isn&#8217;t the first thing to care about.</p>

<h3>Software architecture</h3>

<p>In my opinion, major performance improvements are achieved with good software architecture (this is also true outside of the web context). This field is a very complicated art and very specific to your application, to your needs and your constraints. No one will ever tell you that in a talk, because it is too specific. An architecture consists of deciding which components compose your system, which role each is playing and how they are going to communicate. This is complicated.</p>

<h3>Algorithms</h3>

<p>This one is also independent of the context of the web. Know your classic algorithms. Know when to use them. Also know when not to use them. For short lists, a bubble sort can be faster than a quick sort.</p>

<p>In &#8220;algorithms&#8221;, I also put knowing when to use parallelism, knowing the different sort of parallelisms. This isn&#8217;t easy, distributed algorithms are not the easiest thing even in a master/workers paradigm.</p>

<p>I&#8217;ll get back to this point about algorithms <img src="http://localhost/wp/wp-includes/images/smilies/icon_smile.gif" alt=":-)" class="wp-smiley" /> </p>

<h2>Web performance</h2>

<p>The web has some well-known constraints and it induces things to know to improve performance</p>

<h3>Network</h3>

<p>As said <a href="http://erights.org/talks/thesis/markm-thesis.pdf">elsewere</a>, no matter how much computers (CPUs) become faster, light speed won&#8217;t increase and the distance between Bordeaux and San Diego is going to stay the same (continental drift aside). This creates an unbreakable physical boundary to speed at which you can transmit a web page. We are not even close to reaching that limit since the transmitted information doesn&#8217;t take the shortest path and rarely reach light speed.</p>

<p>As a consequence, reduce the amount of communication and round trips to the minimum. This will be your first major win. Among the practical tips, use HTTP caching and reduce asset sizes.</p>

<h3>The DOM and graphics</h3>

<p>Since JavaScript has gotten fast, the bottleneck of web scripting is the DOM. DOM objects are weird beast which access isn&#8217;t as efficiently optimized than ECMAScript objects. Also, manipulating DOM objects often performs some graphics operation. These are costly. Change things on the screen only when necessary.</p>

<p>Touch the DOM only when needed. Specifically, don&#8217;t use the DOM to store information (in data-urls). Use your own objects.</p>

<h3>Now, let&#8217;s talk about JavaScript</h3>

<p>The first advice is knowing the language. It takes time, but it&#8217;s worth it to avoid reimplementing inefficiently what the language can do efficiently for you.</p>

<p>Then, write clean modular code (it&#8217;s a sort of follow-up of the above &#8220;good architecture&#8221; advice) and it will do most of the job to avoid useless computation.</p>

<p>If you have followed all the advice above in the provided order (and that&#8217;s a LOT of work!) and your application still have a performance issue, now you can start considering following Daniel Clifford&#8217;s advices.</p>

<h3>Partial conclusion</h3>

<p>Above, I&#8217;ve tried to step back on performance to explain that engine-specific optimizations are the last thing to take care of (because they yield the smallest benefit by comparison to the other things) because the talk was a bit elusive on that point.</p>

<p>It doesn&#8217;t mean knowing JS engines and knowing how to write efficiently for them is a stupid idea. It just mean that&#8217;s not the first thing you should care about, and as I said above, in my opinion, it&#8217;s the last.</p>

<h2>Critique of the rest of the talk</h2>

<h3>The performance problem to be solved</h3>

<p>Compute the 25000th prime number. Quote from the talk (emphasis added):<br>
&#8220;I have put together a sample problem that I&#8217;d like to talk about throughout the course of this talk. It is a toy problem that I come up with but <strong>I think it&#8217;s representative of some of the things of some of the performance problem that you might face in your own code</strong>&#8221;</p>

<p>In a very American-bullshit-communication style, we here have a sentence that is purposefully vague and say exactly nothing but uses a lot of well-chosen and confusing words to do so (from what I know, it&#8217;s a very cultural thing). Remove the source of vagueness (&#8220;I think&#8221;, &#8220;some&#8221; and &#8220;might&#8221;) and you have a sentence that&#8217;s wrong. The very large majority of web developers do not have this problem or a problem related to this sort of heavy computation. For the large majority, the biggest client-side computation issue is probably sorting a bunch of table rows.</p>

<p>I have to admit that I&#8217;m annoyed by this attempt to justify something wrongly. Acknowledge that JavaScript performance isn&#8217;t an issue for a majority of webdevs and move on! Anyway&#8230;</p>

<h3>The benchmarked algorithm and the talk conclusion (WARNING: SPOILER!)</h3>

<p>After the description of the problem is the description of an algorithm to solve this problem. The algorithm is naive, but this talk isn&#8217;t about algorithms, so it doesn&#8217;t matter at all.</p>

<p>The talk gives tips to improve JavaScript code for performance. Most of them are legitimate and fortunately concur with good practices. One which brings a major improvement is fixing a bug in the code. The code was reading out of array bounds. Hmm&#8230; The example is interesting, but that&#8217;s not a performance improvement. That&#8217;s just fixing a bug. V8 hasn&#8217;t made your code faster. You just made your code correct, it&#8217;s dishonest to compare things that do not work the same way.</p>

<p>And the conclusion. One of the biggest scams of all times in the history of tech talks. The algorithm is changed from a linear algorithm to a square-root complexity algorithm. Guess what! 350 times speedup! No kidding!</p>

<p>I guess that&#8217;s a Google IO talk, so you&#8217;ve got to do a show and show takeaway numbers so people at the end of the talk can say &#8220;with V8 you can achieve a 350 times speedup!&#8221;, but once again, that&#8217;s just dishonest. If your product is really good, why do you need to lie or confuse people? My question is genuine.</p>

<p>Since changing of algorithm is ok to solve the problem faster, I&#8217;d like to propose another algorithm which is simple, so I&#8217;m convinced will be even faster: <code>function answer(){return 287107;}</code>. But I feel too lazy to benchmark this one&#8230;</p>

<h2>Conclusion</h2>

<p>The talk has valuable advices and I recommend it for this content. However, I&#8217;m really unsatisfied of how the talk is constructed and &#8220;packaged&#8221;. Explanation at the beginning of the web performance priorities would have been good. Also, the couple of scams the talk contains are sad, mostly because they are unnecessary.</p>

</div>


          <div class="footer">
            <div class="contact">
              <p>
                Your Name<br />
                What You Are<br />
                you@example.com
              </p>
            </div>
            <div class="contact">
              <p>
                <a href="https://github.com/yourusername">github.com/yourusername</a><br />
                <a href="https://twitter.com/yourusername">twitter.com/yourusername</a><br />
              </p>
            </div>
          </div>
        </div>

    </body>
</html>
