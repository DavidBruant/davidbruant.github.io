<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>Web technologies are implementation and content-driven</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/css/main.css">

    </head>
    <body>

        <div class="site">
          <div class="header">
            <h1 class="title"><a href="/">Long-term laziness</a></h1>
            <a class="extra" href="/">home</a>
          </div>

          <h2>Web technologies are implementation and content-driven</h2>
<p class="meta">14 Mar 2012</p>

<div class="post">
<p>I&#8217;ve been teaching some web technologies lately and I found myself telling the exact same story over and over again. Something along the lines of &#8220;feature X has initially been added in browser Y. Web developer used it, so other browsers copied it after reversed-engineering, bugs included&#8221;. If the feature has bugs, it must be standardized as such since content in the wild may rely on particular behaviors (bugs included) to run/be rendered properly. Standardizing a feature in a way that is not backward-compatible with existing content is called &#8220;breaking the web&#8221; in standards mailing-list and obviously, no one ever wants to do that!</p>

<p>The above quote is pretty much how everything happened after HTML4, CSS2 and ECMAScript 3 CSS (all released in 1998-1999). HTML5, CSS2.1 (and 3 to some extent) and ECMAScript 5 have been works of understanding and standardizing web technologies how they were actually implemented in browsers and used by web authors&#8230; and adding a few features. Such work is still ongoing is isn&#8217;t likely to be finished anytime soon.</p>

<h2>Examples</h2>

<h3>JavaScript</h3>

<p>A very early example is the inclusion of JScript in Internet Explorer, soon after Nescape shipped JavaScript. The name does not matter a second, but what did at the time was for Microsoft to run the content (and specifically scripts) written by web authors for Netscape. As the rumor goes, <code>typeof null === &#39;object&#39;</code> was a bug in the original Netscape version that has been copied by Microsoft (and later standardized as it should since changing that could have broken scripts)</p>

<h3>Microsoft innovations</h3>

<p>In the opposite direction, Microsoft invented .innerHTML and <iframe>s which have been used by web authors and very soon have been implemented in other browsers. Later standardized as part of HTML5.</p>

<h3>This day deployed jQuery influenced ECMAScript 5</h3>

<p>I&#8217;ll let you read this <a href="http://blogs.msdn.com/b/ie/archive/2010/07/16/how-ie9-platform-preview-feedback-changed-the-javascript-standard.aspx">interesting announcement</a> where is described how some deployed jQuery code enforced a change in ECMAScript.</p>

<h3>Enters mobile web: Internet Explorer may consider implementing <code>__proto__</code></h3>

<p>It came as a shock when I first read that <a href="https://mail.mozilla.org/pipermail/es-discuss/2011-December/019083.html">Microsoft was considering implementing <code>__proto__</code></a>, but it makes a lot of sense. The mobile world is dominated by browsers implementing <code>__proto__</code> (Safari, Opera), so naturally (?), people writing <a href="https://github.com/madrobby/zepto/blob/master/src/zepto.js#L74">mobile libraries</a> or mobile web content take it for granted.</p>

<h3>-webkit-what?</h3>

<p>There has been a huge debacle about browsers considering to implement -webkit- CSS properties. No one is really happy of the state of things, but reality is that there is content relying on -webkit- properties. If a new browser wants to enter the mobile field, it has to render existing websites and unfortunately, it seems unavoidable to implement some -webkit- properties.</p>

<p>Just to clarify, I&#8217;m not expressing a judgement or an opinion here, just stating facts and drawing the natural conclusion that comes out of it.</p>

<h3>&#8220;WTF??!!1! H.264 videos in Firefox?? Is Mozilla forgetting its mission?&#8221;</h3>

<p>An <a href="https://groups.google.com/d/msg/mozilla.dev.platform/-xTei5rYThU/DkM9AIbkNNIJ">interesting thread started by Andreas Gal</a> discusses the possibility for B2G to use OS codecs when they are available, even for H.264 (including .flv videos which are certainly the most widespread video format on the web) and MP3. As one can imagine, support for these patent-encumbered formats in Firefox after &#8220;fighting&#8221; against them for so long is at the very least surprising. But it makes sense too: since there is no Flash on iPhones, it is very likely that web apps with video elements embed H.264 videos (only format supported on iphones according to <a href="http://caniuse.com/#search=video">caniuse</a>). Android also supports this.</p>

<p>Knowing that there is H.264 video content out there on mobile websites, what choice is left to Mozilla? Not render any video and never enter the mobile market? As hard as it is for me to accept it, this is certainly not the right choice. I think supporting H.264 when the OS has a codec for it is a reasonable sacrifice to be made in order for Mozilla to reach users and bring its vision of how the web should be with B2G, persona, apps and the likes.</p>

<p>Anyway, back to the main topic&#8230;</p>

<h3>Last but not least: &#8220;Encrypted Media proposal&#8221;</h3>

<p>This example is not in a mature stage as the previous ones. No one implemented it and there is no content for this now, but <a href="http://dvcs.w3.org/hg/html-media/raw-file/tip/encrypted-media/encrypted-media.html">Microsoft, Google and Netflix are proposing an extension for encrypted media</a>. As far as I&#8217;m concerned, just the initial picture seems too complicated to be realistic.</p>

<p>But technical difficulties are not that big of a deal. Some quotes in a discussion thread are more disturbing: <a href="http://lists.w3.org/Archives/Public/public-html/2012Mar/0084.html">&#8220;Our business wouldn&#8217;t be viable at all without regional restrictions.&#8221;</a> or the no less excellent: <a href="http://lists.w3.org/Archives/Public/public-html/2012Mar/0411.html">&#8220;[Content Decryption Modules] implementations that may not be [Free and Open Source Software]-implementable *are* at this time (but not necessarily in the future) a business requirement for the<br>
commercial video provider members of the W3C&#8221;</a>.</p>

<p>The careful reader will make the connexion between the &#8220;at this time&#8221; and &#8220;in the future&#8221; and realize that if the CDM technology is deployed and has content relying on it, no matter if &#8220;commercial video provider members of the W3C&#8221; change their mind, the content relying on the initial CDM technology will never be readable by FOSS and that&#8217;s a bit annoying, isn&#8217;t it?</p>

<h2>Counter-examples</h2>

<h3>ActiveX, VML</h3>

<p>No one really ever implemented that besides Microsoft. Certainly because there was few to no content to support.</p>

<h3>Firefox&#8217;s __noSuchMethod__</h3>

<p>Hopefully, you don&#8217;t even know what that it and that&#8217;s a good thing <img src="http://localhost/wp/wp-includes/images/smilies/icon_smile.gif" alt=":-)" class="wp-smiley" /> </p>

<h2>Standards and validators</h2>

<p>So I&#8217;ve claimed that web technologies are driven by implementation and content, but there are technical standards and validators, right? Software standards used to be this almost sacred thing that implementors had to follow and it was a working model. That&#8217;s how web standards were originally thought. But that&#8217;s not a relevant model anymore. The <a href="http://wiki.whatwg.org/wiki/FAQ#What_is_the_WHATWG.3F">WHATWG (group behind HTML5) was founded by browser makers</a>, because there was a need for web browsers to agree on what they implemented and to implement it in an interoperable way, with the &#8220;don&#8217;t break the web&#8221; rule as a priority that apparently the W3C had not understood (but <a href="http://vimeo.com/groups/93576/videos/19099716">Bruce Lawson explains it</a> better than I do)</p>

<p>I really think we should stop thinking standards as Bible-like texts, but rather as an <strong>implementation agreement</strong>. Obviously, since there is the backward compatibility constraint, there is a need for implementors to hear about what web authors (aka &#8220;developers&#8221;) have to say about how they currently use the technologies and standards mailing lists are open to this. Finally, web authors can provide feedback and suggestions to new features. That&#8217;s a rough and incomplete picture of how web standards currently work and I&#8217;m glad it does work like this.</p>

<p>Also, very much like implementations (software) evolve, so must the standards, hence the <a href="https://plus.google.com/107429617152575897589/posts/NZBJe6Jjt1f">HTML living standard model</a>.</p>

<p>In the end, there are validators. I have met some people who would never ship a website if all pages do not validate. This is a wrong idea. Validators are the continuity of the ideal that standards are sacred texts. They are as wrong. They are even more wrong if the validator is kept up to date against the latest evolution of web standards (and I am confident they are not). Moreover, the analysis they provide is only partial. As any piece of software, validators can have bugs. Worse than anything else, a validator does not guarantee your content to actually renders properly on web browsers (which is what you actually care about when writing a page). Anyway, you can use validators, but stay critical on their limitations.</p>

<h2>HOWTO: remove annoying technologies</h2>

<p>Most of the time, it won&#8217;t be possible. However, in some cases, some technologies are used only in a certain way and it&#8217;s still possible to standardize the technology with a restriction. Obviously, it requires a study of how people use the technologies. This was not so hard for the __proto__ &#8220;property&#8221; and led to a <a href="http://wiki.ecmascript.org/doku.php?id=strawman:magic_proto_property">very reasonable proposal</a> that&#8217;s unlikely to break the web.</p>

<p>It is a vastly more complicated work when <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=708406">vendor-specific CSS properties</a>. Here, the outcome would be to decide which properties Mozilla is willing to implement rather than which properties could be removed, but the same result could be used by Webkit to remove the rarely used properties.</p>

<h2>Looking forward</h2>

<p>For a web technology to be adopted, it takes 2 ingredients: 1) implement it in a wide-spread browser 2) create content using (and relying on) this technology. In retrospect, the whole prefix thing was doomed to fail. It was basically saying &#8220;we&#8217;ll do 1, but please, developers all around the world, don&#8217;t do 2!&#8221;. Clearly not a winning startegy. Needless to say that <a href="http://www.glazman.org/weblog/dotclear/index.php?post/2012/02/09/CALL-FOR-ACTION%3A-THE-OPEN-WEB-NEEDS-YOU-NOW">every attempt</a> to <a href="http://codepo8.github.com/prefix-the-web/">evangelize against prefixes</a> is meant to fail since it&#8217;s not possible to change all the content of the web (remember it&#8217;s decentralized and all of that?)</p>

<h2>Conclusion</h2>

<p>If I was ever asked, my advice to browsers would be: be careful of what you implement and ship, otherwise, everyone may get stuck!</p>

</div>


          <div class="footer">
            <div class="contact">
              <p>
                Your Name<br />
                What You Are<br />
                you@example.com
              </p>
            </div>
            <div class="contact">
              <p>
                <a href="https://github.com/yourusername">github.com/yourusername</a><br />
                <a href="https://twitter.com/yourusername">twitter.com/yourusername</a><br />
              </p>
            </div>
          </div>
        </div>

    </body>
</html>
